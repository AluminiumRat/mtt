# Кратко
Запускаем просчет физики в паралелльном потоке.

# Вместо предисловия
Не то чтобы этот пример очень полезен, но так случилось, что он есть. Главное, что вы можете почерпнуть из него - это использование рабочего цикла приложения и запуск действий, синхронизированных или асинхронных по отношению к рендеру или друг к другу. Ну, или можно просто расслабиться и посмотреть, как шарики и кубики прыгают по экрану.

Пример содержит довольно большое количество кода, но вы смело можете пропустить большую его часть. Так, например, папка Physics содержит исключительно реализацию физического движка, и вы можете туда даже не заглядывать, если вам не интересно его внутреннее устройство. Вы также можете пропустить большую часть глав из этого файла и сразу перейти к главе "Рабочий цикл и обновление физики".

# Интерфейс
По интерфейсу всё просто. Двойной клик левой кнопкой мыши добавляет шар, двойной клик правой кнопкой - куб. Управление камерой такое же, как и в других примерах.

# Физический движок
Итак, вы зачем-то решили разобраться в работе физического движка. Сразу предупреждаю, не стоит ждать от него чего-то серьёзного. Это всего лишь демонстрационный пример.

Движок двумерный, импульсный. Взаимодействия объектов - упругие, но с поглощением части энергии. Силы трения отсутствуют. Значительная часть идей была почерпнута из цикла статей "How to Create a Custom Physics Engine"(https://gamedevelopment.tutsplus.com/series/how-to-create-a-custom-physics-engine--gamedev-12715), рекомендую заглянуть туда для лучшего понимания.

Весь код, относящийся к физике, находится в папке Physics. Прежде всего стоит обратить внимание на класс PhysicsObject. Это абстрактный класс, который реализует базовые физические свойства, а также объявляет метод PhysicsObject::intersect, с помощью которого мы можем обнаруживать столкновения между объектами. Классы PhysicsBoxObject и PhysicsCircleObject наследуются от PhysicsObject и реализуют, по большому счету, только вычисление точек столкновения.

Класс PhysicsScene используется для того, чтобы объединить отдельные физические объекты вместе и обеспечить взаимодействие между ними. Именно здесь реализуется главный цикл физического движка (метод PhysicsScene::applyTime). На каждом шаге симуляции происходит поиск столкновений между объектами, и для каждого столкновения создает объект класса Contact. После того как к объектам применяется сила гравитации, происходит разрешение контактов, то есть поиск импульсов силы, вызванных столкновениями объектов. В конце цикла для каждого объекта обновляются положение и вращение.

Contact - это класс, обрабатывающий взаимодействие между двумя физическими объектами. То есть именно он вычисляет и применяет к объектам импульсы, возникающих при столкновении объектов. Принцип действия довольно прост. Для начала мы вычисляем penetrationSpeed, то есть скорость взаимного проникновения объектов в точке контакта. Наша цель - применить к объектам такие импульсы, чтобы они отскакивали друг от друга с такой же скоростью, но умноженной на bounceFactor (bounceFactor отвечает за поглащение энергии при ударе).

    _bounceSpeed = bounceFactor * penetrationSpeed;

Для того чтобы вычислить импульс силы при ударе, мы сначала используем пробный импульс(probingImpulse и invProbingImpulse) и смотрим, насколько изменится скорость проникновения от него. На этапе resolve мы просто масштабируем пробный импульс, чтобы добиться нужной скорости отскока.

# Интеграция mtt и физики
Для объединения рендера и физики используются всего 2 класса. Класс Object владеет одним физическим объектом(PhysicsObject) и одним дравэйблом. Его назначение - это регистрация/дерегистрация этих объектов в соответствующих сценах, а также синхронизация положения дравэйбла с физическим объектом.

Класс World - это, по большому счету, хранилище объектов класса Object. Через него добавляются новые объекты на сцену, он же удаляет объекты, которые оказались за границами сцены (например упали вниз).

# Рабочий цикл и обновление физики
Обновление физики производится через специальный класс UpdateWorldAction. Экземпляр этого класса создается в функции main и добавляется в рабочий цикл приложения:

    application.workCycle.addAction(std::make_unique<UpdateWorldAction>(world),
                                    UpdateWorldAction::actionCategory,
                                    mtt::WorkCycle::PRERENDER_PRIORITY,
                                    true);

Рабочий цикл(класс mtt::WorkCycle) - это набор действий, которые постоянно выполняются приложением. Так, например, рендер виджет добавляет в рабочий цикл команду отрисовки (класс mtt::RenderSceneAction).

Для того чтобы создать собственное действие для рабочего цикла, необходимо унаследовать его от интерфейса mtt::WorkCycle::AbstractAction и переопределить три метода: asyncPart - асинхронная часть действия, может быть вызвана в любом потоке, preAsycPart - вызывается в GUI потоке перед вызовом asyncPart, postAsycPart вызывается в GUI потоке после вызова asyncPart.

Метод WorkCycle::addAction имеет 4 аргумента:

    void addAction( std::unique_ptr<AbstractAction> action,
                    int category,
                    int priority,
                    bool permanent);

Здесь нас интересует в первую очередь параметр category. Категория - это механизм синхронизации, позволяющий избежать гонок по данным. Класс WorkCycle гарантирует, что 2 действия, имеющих одинаковую категорию, не будут выполняться одновременно. Именно поэтому мы создаем отдельную категорию для обновления физики:

    const int UpdateWorldAction::actionCategory =
                                        mtt::WorkCycle::createActionCategory();

Это позволяет просчитывать физику параллельно с рендером. Если бы мы использовали категорию mtt::RenderSceneAction::actionCategory, то обновление физики и рендер происходили бы последовательно.

Параметр priority используется для упорядочивания вызовов синхронных частей, то есть методов preAsycPart и postAsycPart. Первыми вызываются действия с наибольшим приоритетом.

Параметр permanent позволяет добавлять одноразовые действия. Установите его в false, и действие будет автоматически удалено сразу после выполнения. В противном случае оно будет выполняться раз за разом, пока вы не удалите его с помощью mtt::WorkCycle::removeAction.

Вернемся к нашей UpdateWorldAction. Так как физический движок у нас полностью независим от рендера, то мы можем вызывать его обновление асинхронно. Хотя метод UpdateWorldAction::asycPart и выглядит громоздко, но на самом деле здесь происходит всего лишь подсчет времени между кадрами и разбиение его на небольшие равные куски для корректной работы физического движка.

Синхронизацию объектов рендер сцены и физических объектов мы можем выполнять только последовательно с рендером и просчетом физики. Поэтому её мы производим в методе UpdateWorldAction::postAsycPart.