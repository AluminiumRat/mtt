# Кратко
Учимся собирать сцены, рисуем четырехугольник с помощью mtt::Mesh и текстурируем его.

# Сцена
Несмотря на то что сцена вообще-то предполагает внешнее хранение объектов, мы можем исправить это, создав новый класс и унаследовавшись от mtt::RenderScene.

    class Scene : public mtt::RenderScene
    {
    private:
      mtt::Mesh mesh;

Меш - это единственный объект на нашей сцене, и сцена теперь владеет им (меш будет уничтожен вместе со сценой). Тем не менее, его всё равно надо зарегистрировать

    addUnculledDrawable(mesh);

Обратите внимание, что меш будет уничтожен во время деструкции нашего класса Scene, и ко времени уничтожения класса mtt::RenderScene его не будет существовать. Поэтому вызовем removeUnculledDrawable в деструкторе нашей сцены, чтобы не оставлять битую ссылку.

    ~Scene()
    {
      removeUnculledDrawable(mesh);
    }

# Меш
mtt::Mesh - это класс, предназначенный для отрисовки объектов, которые можно представить в виде набора вершин. Это может быть множество треугольников, линий или отдельных точек. Он объединяет в себе данные вершин, дополнительные общие данные(например текстуры или данные материала) и техники рисования.

Меш унаследован от mtt::Drawable, но не от mtt::DrawableNode, поэтому его нельзя напрямую добавить в сцену с помощью RenderScene::addCulledDrawable. Вместо этого мы добавляем его как unculled объект, чего вполне достаточно для этого примера. Для того чтобы использовать меши как culled объекты, их необходимо оборачивать с помощью класса mtt::SimpleDrawableNode.

## Данные вершин
Прежде всего позаботимся о данных вершин, для этого создадим вершинный буфер и подключим его к мешу

    std::vector<glm::vec3> positionsData ={ glm::vec3(-1.f, -1.f, 0.f),
                                            glm::vec3(-1.f,  1.f, 0.f),
                                            glm::vec3( 1.f, -1.f, 0.f),
                                            glm::vec3(-1.f,  1.f, 0.f),
                                            glm::vec3( 1.f,  1.f, 0.f),
                                            glm::vec3( 1.f, -1.f, 0.f) };
    std::shared_ptr<mtt::Buffer> positionBuffer =
      std::make_shared<mtt::Buffer>(displayDevice, mtt::Buffer::VERTEX_BUFFER);
    positionBuffer->setData(positionsData.data(),
                            positionsData.size() * sizeof(positionsData[0]));
    mesh.setPositionBuffer(positionBuffer);

Вершинный буфер - это просто экземпляр класса mtt::Buffer, созданый с флагом VERTEX_BUFFER. Буфер - это всего лишь участок памяти на стороне GPU, он не привязан к какому-либо типу данных, поэтому заполняется сырыми данными с помощью метода Buffer::setData. Объект std::vector<glm::vec3> - это всего лишь удобная RAII обертка для временного хранения данных на стороне хоста.

Итак, мы создали буфер, в котором хранятся координаты вершин. Но почему-то вершин шесть вместо четырех. Дело в том, что mtt::render не умеет рисовать четырехугольники, поэтому нам потребовалось разбить прямоугольник на 2 треугольника, каждый по 3 вершины.

Кстати, обратите внимание, что хотя mtt::render и не ограничивает вас в выборе системы координат сцены, но многие классы и методы предполагают, что система координат будет правой, а ось Z направлена вверх.

Мы создали буфер, в котором находятся координаты вершин, также нам потребуется буфер с текстурными координатами, его создание полностью аналогично первому.

Для того чтобы присоединит буферы к мешу мы используем методы Mesh::setPositionBuffer и Mesh::setTexCoordBuffer. Обратите внимание, что мы передаем в меш std::shared_ptr, то есть вершинные буферы могут быть разделены между несколькими мешами.

Кроме самих данных вершин мы также обязательно должны указать количество вершин:

    mesh.setVerticesNumber(positionsData.size());

## Текстура
Текстуру можно представить просто как картинку, хранящуюся на стороне GPU и доступную на чтение во время отрисовки. Наша цель - натянуть изображение на рисуемый прямоугольник. Мы уже присоединили текстурные координаты к мешу, теперь загрузим и подключим текстуру.

    std::shared_ptr<mtt::Texture2D> texture =
        mtt::Texture2DLibrary::loadTexture(":/scream.jpg", displayDevice, true);

Здесь происходит сразу несколько фокусов, на которые стоит обратить внимание. Во-первых для загрузки текстуры мы используем Texture2DLibrary. Библиотека текстур - это объект, который позволяет централизованно загружать и хранить текстуры, которые совместно используются сразу несколькими мешами. Но в нашем примере меш один, поэтому мы используем статический метод Texture2DLibrary::loadTexture и не используем библиотеку для хранения текстур. Создайте объект mtt::Texture2DLibrary и используйте нестатический метод Texture2DLibrary::load, если хотите разделять текстуры между мешами.
Вторая особенность - это имя файла ":/scream.jpg". Если вы уже пользовались системой ресурсов Qt, но наверняка догадались, в чем дело. На самом деле текстура загружается не из внешнего файла, а из самого исполняемого файла приложения. Посмотрите в CMakeListst.txt этого примера:

    add_executable (Mesh
                    "main.cpp"
                    "../resources/scream.qrc")

Мы подключили к проекту scream.qrc из папки resources, заставив cmake обработать его с помощью rcc. Если вам это вновь, то ознакомьтесь с документацией по Qt resource system.

Текстура подключается к мешу через сэмплер. Если текстуру можно представить как изображение(данные), то сэмплер - это способ извлечения этих данных из памяти. Это использование min и mag фильтров, обработка выхода за границу(VkSamplerAddressMode) и т.д.

    std::unique_ptr<mtt::Sampler> sampler =
                  std::make_unique<mtt::Sampler>( mtt::PipelineResource::STATIC,
                                                  displayDevice);

Флаг mtt::PipelineResource::STATIC означает, что ни сам сэмплер, ни текстура не будут изменяться во время работы приложения, либо будут меняться редко. Это позволяет включить некоторые оптимизации и немного увеличить производительность.

    sampler->setAttachedTexture(texture);
    mesh.extraData().setAlbedoSampler(std::move(sampler));

Тут мы просто прикрепили текстуру к сэмплеру, а сэмплер к мешу. Сэмплер прикреплен как альбедо сэмплер, то есть он отвечает за цвет поверхности. Вообще, текстура может интерпретироваться как угодно, это и карта нормалей, и шероховатость, и температура, если, конечно, вы реализуете технику отрисовки нагретой поверхности. Но здесь мы ограничимся просто цветом.

# Техника рисования
Последнее что нам осталось - это назначить технику рисования.

    mesh.setTechnique(
              mtt::clPipeline::colorFrameType,
              std::make_unique<mtt::clPipeline::UnlightedColorTechnique>(
                                          true,
                                          true,
                                          VK_COMPARE_OP_GREATER_OR_EQUAL,
                                          VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST));

Техника рисования инерпретирует каким-либо образом данные, подключенные к мешу и формирует команды для его отрисовки.

Мы используем здесь технику clPipeline::UnlightedColorTechnique. При её использовании источники света никак не влияют на результат, с ними мы познакомимся в других примерах. Первые два параметра конструктора - это включение/выключение теста глубины и записи в буфер глубины, третий(VK_COMPARE_OP_GREATER_OR_EQUAL) - это операция, выполняемая при тесте глубины. Четвертый параметр - это топология меша, то есть способ интерпретации вершин. Мы можем представить меш как набор треугольников(как в этом примере), как набор отрезков(VK_PRIMITIVE_TOPOLOGY_LINE_LIST) или как набор точек(VK_PRIMITIVE_TOPOLOGY_POINT_LIST). Есть ещё ряд доступных топологий, подробнее с ними можно ознакомиться в документации Vulkan по enum-типу VkPrimitiveTopology.

Обратите внимание на первый аргумент метода Mesh::setTechnique - это тип фрэйма(кадра). Дело в том, что один и тот же меш может быть отрисован не только на экран, но и, скажем, в карту теней или в карту id. Для каждого из этих типов изображений мы можем выбрать свою технику рисования. В текущем примере нас интересует только вывод на экран, поэтому технику рисования назначим только для clPipeline::colorFrameType.

# Шейдеры mtt
Как вы, наверное, знаете, шейдеры - это небольшие программы, выполняемые на стороне GPU. В mtt они хранятся в папке shaders корневого каталога. Техника рисования загружает шейдеры и использует для отрисовки.

Для того чтобы не таскать шейдеры в виде отдельных файлов вместе с исполняемым файлом используется библиотека mtt::shaders(файл CMakeLists.txt прямо в папке shaders). Она позволяет встроить шейдеры прямо в файл приложения. Принцип тут тот же, как и для текстуры scream.jpg - мы используем ресурсы Qt. Но для этого нам необходимо добавить в функцию main код, который не позволит линкеру отбросить шейдеры при сборке:

    Q_INIT_RESOURCE(shaders);

# OrbitalCameraController
Небольшой бонус к уроку - это контроллер камеры.

    mtt::OrbitalCameraController cameraController(window, nullptr);

Этот объект подключается к рендер виджету и перехватывает управление камерой. Используйте мышь для того чтобы рассмотреть созданный мешь со всех сторон.
