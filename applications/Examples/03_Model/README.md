# Кратко
Загружаем модель из файла и анимируем её. Добавляем освещение.

# Детально
## Мастер-модель
Модель - это Drawable-нода, которая состоит из одного или нескольких мешей, а также содержит в себе иерархию Joint-нод и набор анимаций. В этом примере мы рассмотрим мастер-модели, то есть модели, не зависящие от других.

Самый простой способ загрузить модель из файла - это использовать загружающий конструктор. В нашем примере модель является частью сцены:

    class Scene : public mtt::RenderScene
    {
    private:
      mtt::MasterDrawModel drawModel;
    ...
    Scene(mtt::MeshTechniquesFactory& techniquesFactory,
          mtt::LogicalDevice& displayDevice) :
      drawModel(":/Dino.mmd", techniquesFactory, nullptr, displayDevice),

Первый параметр - это имя файла. В нашем случае мы используем систему ресурсов Qt, чтобы не таскать файл модели вместе с исполняемым файлом. Второй параметр - это фабрика техник, о ней речь пойдет немного позже. Третий параметр - указатель на библиотеку текстур, её стоит использовать, если вы хотите переиспользовать одни и те же текстуры в нескольких моделях. У нас всего одна модель, поэтому и библиотека текстур нам не нужна, передаем nullptr.

Модель - это DrawableNode, она имеет ограничивающую сферу, поэтому мы можем добавить её на сцену, как culled объект:

    addCulledDrawable(drawModel);

Не забываем убрать модель из сцены в деструкторе:

    removeCulledDrawable(drawModel);

## Фабрика техник
Модели отрисовываются с помощью объектов mtt::Mesh. Файлы моделей содержат данные для этих мешей, но техники рисования приложение должно установить само. Было бы очень неудобно обходить все меши и вручную назначать им техники, как мы делали это в примере 02_Mesh, поэтому мы используем другой механизм - фабику техник.

Для начала мы создаем саму фабрику. Так как для рендера мы используем clPipeline, то и фабрику берем из этой же библиотеки:

    mtt::clPipeline::ModelTechniquesFactory techniquesFactory(
                                          true,
                                          false,
                                          false,
                                          false,
                                          false,
                                          VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);

Булевы флаги в конструкторе - это настройки того, какие именно техники надо добавить в меш. Нас интересует только техника отрисовки на экран, остальные флаги установим в false. Последний параметр - это топология, мы уже говорили о ней в примере 02_Mesh. Загрузчики моделей поддерживают только VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST и VK_PRIMITIVE_TOPOLOGY_POINT_LIST. Можете подставить эти значения и посмотреть, что получится.

После того как мы создали фабрику, мы можем передать ссылку на неё в конструктор модели. Каждый раз, когда будет создан новый меш и загружены все данные для него, загрузчик будет вызывать фабрику. Фабрика создаст все необходимые техники рисования и присоединит их к мешу.

## Анимация
Файлы моделей могут содержать не только геометрию, но также и анимации. Вы можете получить их через методы MasterDrawModel::animationsNumber, MasterDrawModel::animation или MasterDrawModel::findAnimation. В этом примере мы заранее знаем, как называется анимация, поэтому ищем её по имени:

    mtt::DrawModelAnimation* animation = drawModel.findAnimation("Walk");

Сама по себе анимация - это всего лишь информация о том, как меняется модель со временем, поэтому для проигрывания анимации нам потребуется сделать простенький плеер на основе QTimer:

    QTimer updateTimer;
    mtt::TimeT animationTime;
    ...
    updateTimer.setSingleShot(false);
    QTimer::connect(&updateTimer,
                    &QTimer::timeout,
                    [&, animation]
                    {
                      if(animation != nullptr)
                      {
                        drawModel.updateFromAnimation(
                              *animation,
                              animation->timeRange().start() + animationTime);
                        animationTime += 30 * mtt::millisecond;
                        animationTime %= animation->timeRange().length();
                      }
                    });
    updateTimer.start(30);

Каждые 30 секунд таймер запускает лямбда-функцию, которая увеличивает текущее время анимации и вызывает метод MasterDrawModel::updateFromAnimation. Этот метод считывает из анимации положения всех джоинтов и перемещает их, а так как скелет мешей определяется джоинтами, то и скин-модель тоже меняется.

## Освещение
Добавим на сцену освещение, чтобы модель выглядела объемно. Источники света - это объекты, сильно зависящие от реализации системы рендера. Поэтому в mtt они находятся в библиотеке clPipeline. Мы будем использовать clPipeline::AmbientLight и clPipeline::DirectLight.

Источники света в нашем примере - это члены класса сцены, поэтому их декларация и инициализация разнесены:

    mtt::clPipeline::AmbientLight ambientLight;
    mtt::clPipeline::DirectLight directLight;
    ...
    ambientLight(true, true, true, displayDevice),
    directLight(true, true, displayDevice)

AmbientLight - это источник, предназначенный для имитации освещение от окружающих предметов, таких как скейбокс или другие меши и модели. В этом примере мы будем использовать самый примитивный вариант - равномерное освещение со всех сторон.

Библиотека clPipeline реализует и forward и deferred техники освещения, поэтому источники света являются композитными объектами, так как должны включать в себя и модификаторы областей и дравейблы. Посмотрите на конструктор mtt::AmbientLight

    explicit AmbientLight(bool forwardLightingEnabled,
                          bool defferedLightingEnabled,
                          bool infinityAreaMode,
                          LogicalDevice& device);

Первые два флага как раз и отвечают за то чтобы включить/отключить соответствующую технику наложения света. Флаг infinityAreaMode отвечает за то, является ли источник освещения локальным (действует только в определенной области), либо распространяется на всю сцену. Мы включаем и forward и deferred освещение, а также используем режим бесконечной области.

    ambientLight.setIlluminance(glm::vec3(.5f, .5f, .5f));
    addCompositeObject(ambientLight);

Здесь мы просто настраиваем яркость и цвет, а после регистрируем источник света на сцене.

DirectLight - это источник, имитирующий прямой солнечный свет. Он распространяется бесконечно вдоль локальной плоскости XY, но ограничен по высоте (это сделано для поддержки карт теней). Его конструктор аналогичен конструктору AmbientLight, за исключением отсутствующего тут infinityAreaMode.

    directLight.setTransformMatrix(glm::translate(glm::vec3(0.f, 0.f, 3.f)));
    directLight.setHeight(5.f);
    directLight.setDirection(glm::vec3(1.f, 1.f, -1.f));
    directLight.setIlluminance(glm::vec3(2.5f, 2.5f, 2.5f));
    addCompositeObject(directLight);

Здесь мы просто подняли источник света на 3 метра вверх и установили освещаемую область в 5 метров. То есть источник освещает все предметы в диапазоне от -2 метров до +3 метров по оси Z. Также мы установили направление лучей методом setDirection и яркость/цвет методом setIlluminance.

Не забываем удалить источники света из сцены в деконструкторе

    removeCompositeObject(ambientLight);
    removeCompositeObject(directLight);
