# Кратко
Строим простую иерархическую модель данных, используем QTreeView для её визуализации.

# Детально
В этом примере мы переходим от рендера к работе с объектной моделью данных.

Пусть у нас есть следующие типы объектов: книга, сумка, человек, кафе-киоск и какая-то комната. В сумку мы можем складывать книги, но человек, киоск или комната туда не поместятся. В кафе-киоске работает повар(человек), а также там есть меню(книга). Ни повара, ни меню из киоска мы забрать не можем. Ну и наконец, в комнату мы можем поместить вообще что угодно.

## Книга(класс Book), человек(класс Human) и mtt::Object
Класс mtt::Object является базовым для построения объектной модели данных в mtt. В этом примере нас интересует, главным образом, его способность к построению иерархических древовидных структур.

Классы Book и Human - самые простые, их мы наследуем от mtt::Object, не добавляя никакой функционал. Класс mtt::Object, хоть и поддерживает работу с подобъектами, но не позволяет добавлять или удалять их извне, методы Object::addSubobject и Object::removeSubobject объявлены как protected.

## Комната и mtt::ObjectGroup
Комната - это своего рода контейнер, в который мы можем положить объект любого типа. Для таких контейнеров mtt предоставляет класс mtt::ObjectGroup, поэтому мы даже не создаем класс Room, а вместо этого добавляем группу в корневой объект нашей иерархии:

    std::unique_ptr<mtt::ObjectGroup> room(
                                          new mtt::ObjectGroup("Room", false));
    ...
    addSubobject(std::move(room));

## Сумка(класс Bag) и mtt::SpecialGroup
Сумка - это специализированный контейнер для книг, ничего кроме книг туда положить нельзя. На самом деле, это - довольно часто встречающийся случай, поэтому для него в mtt существует шаблонный класс mtt::SpecialGroup. Всё что нам надо сделать - это унаследоваться от него и добавить сигналы childAdded и childRemoved.

## Киоск(класс Kiosk)
Киоск мы унаследуем от mtt::Object и воспользуемся тем, что mtt::Object позволяет добавлять и удалять подобъекты только через protected методы:

    addSubobject(std::make_unique<Human>("Cook"));
    addSubobject(std::make_unique<Book>("Menu"));

Теперь повара и меню нельзя удалить из киоска, так же как и нельзя добавить в киоск какой-либо другой объект.

## RootObject
RootObject - это объект, объединяющий все остальные объекты в единое целое. Можно воспринимать его как некий микромир, в котором происходит действие, или как главный объект нашей объектной модели.

## QTreeView и mtt::ObjectItemTreeModel
Как вы можете заметить, наши объекты образуют древовидную структуру. Для работы с такими структурами Qt предоставляет крайне удобный виджет QTreeView. Он, конечно, не поддерживает работу с объектами mtt напрямую, но мы можем использовать адаптер mtt::ObjectItemTreeModel:

    mtt::ObjectItemTreeModel objectModel(root, nullptr);
    QTreeView treeWidget;
    treeWidget.setModel(&objectModel);

Заметьте, что мы включаем поддержку перетаскивания:

    treeWidget.setDragDropMode(QAbstractItemView::InternalMove);

Можете попробовать поперемещать объекты друг в друга, чтобы проверить, соответствует ли модель изначальным требованиям.