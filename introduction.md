# С чего начать
Прежде чем погружаться в знакомство с mtt, не плохой идеей было бы посмотреть демонстрационные примеры. Вы можете найти их исходники в папке applications/Examples. Для простоты примеры пронумерованы, так что можете начинать с первого и идти по возрастанию. Не забудьте заглянуть в файлы readme примеров, чтобы понять, что же именно там происходит.

Вероятно вы уже успели собрать mtt(если нет, то можете почитать README.md). Тогда в папке bin сборочной директории вы найдете собранные примеры. Чтобы запустить их, вам, скорее всего, понадобятся динамические библиотеки QtCore, QtGui, QtWidgets и плагины qt. Можете пока просто скопировать их в папку bin, чтобы запустить примеры и поиграть с ними.

Ещё одной не плохой идеей будет использование Visual Studio. Создайте в корневой папке mtt и запустите bat файл с примерно таким содержимым:

    set BASE_DIR=%CD%
    set MTT_SHADERS=%BASE_DIR%\shaders
    set PATH=%FBX_SDK%\lib\vs2017\x64\release;%PATH%
    set PATH=%QTDIR%\bin;%QTDIR%\include;%QTDIR%\lib;%PATH%
    start devenv %BASE_DIR%

Студия позволит вам довольно легко ориентироваться в коде mtt, пересобирать его и эксперементировать.

# Общие замечания
mtt активно использует механизм исключений. При этом генерируются только исключения std::except. Все методы, которые не могут генерировать исключения, помечены noexcept(кроме сигналов). Исключения не могут быть сгенерированы в методах деструктивного типа (деструктор, дерегистрация, изъятие дочернего объекта). Если во время выполнения этих методов происходит ошибка, то, как правило, сообщение об ошибке записывается в лог и вызывается std::abort. В случае, если ошибка не влияет на дальнейшее выполнение программы, допускается запись в лог без вызова std::abort. Запись в лог и std::abort также применяются в ситуациях, однозначно указывающих на логическую ошибку, например двойное создание синглтона.

Запись в лог ведется с помощью класса mtt::Log. По умолчанию лог пишется в std::cout. Используйте Log::setStream для того чтобы перенаправить лог.

Передача владения объектом (то есть ответственность за удаление объекта) осуществляется только через std::unique_ptr. Если вы передаете в метод сырые указатель или ссылку на объект, то ответственность за его удаление по прежнему остается на вас. Указатели std::shared_ptr используются только для разделяемых ресурсов, таких как текстуры или буферы вершин. Механизм mtt::Lockable используется только для предотвращения преждевременного удаления дескрипторов Vulkan.

mtt использует синглтоны mtt::RenderLibInstance в библиотеке render и mtt::Application в библиотеке application. Вы должны создать эти синглтоны перед использованием библиотеки, так же, как QApplication для Qt. Обратите внимание, что RenderLibInstance входит в состав mtt::Application а mtt::Application унаследован от QApplication, так что вам необходимо создать один единственный объект перед началом работы (cмотрите пример 01_Example).

# Структура на уровне файловой системы
* applications - исходники, компилируемые в исполняемые файлы
  * Examples - демонстрационные примеры
  * IDGenerator - генератор случайных чисел, используется при работе с mtt
  * ObjectEditor - редактор для сборки моделей mmd (внутренний формат 3D моделей)
  * ParticlesEditor - редактор для создания эффектов на основе частиц и симуляции движения воздуха
* cmake - дополнительные скрипты для сборки
* include - заголовочные файлы библиотечных модулей
* shaders - шейдеры для библиотек render и clPipeline
* src - исходники для библиотечных модулей

# Структура на уровне модулей
Mtt не является единой монолитной библиотекой, вместо этого он предоставляет набор отдельных модулей, разделенных по функционалу. Это сделано не только для структурирования, но и для уменьшения внешний зависимостей. Так, например, если вы хотите использовать только рендер, то абсолютно не нужно тянуть зависимость от Qt или FbxSdk.

Библиотечные модули mtt:
* animation. Header only библиотека, реализующая анимацию на основе ключевых кадров. Пока что реализована только ступенчатая и линейная интерполяция.
* application. Библиотека, реализующая часто используемые рутины высокого уровня.
* clPipeline. Надстройка над модулем render, реализующая законченную систему отрисовки.
* editorLib. Надстройка над модулем application и интеграция его с модулем clPipeline. По сути, общий код для ObjectEditor и ParticlesEditor.
* fbx. Небольшая обертка над FbxSDK для облегчения импорта.
* particles. Надстройка над clPipeline, предназначенная для отрисовки эффектов на основе систем частиц.
* render. Базовая библиотека для создания рендер машин. Содержит ООП обертку VulkanSDK, граф сцены, управление планом отрисовки, работу с мешами.
* utilities. Низкоуровневые типы данных и рутины.
* shaders. Упаковка текстов шейдеров внутрь библиотечного файла, используется для того чтобы не таскать с собой папку shaders при распространении исполняемых файлов.

Зависимости между основноми компонентами можно представить в виде схемы:

    Vulkan SDK                      glm         Qt  FbxSDK
      |     |                       | |         ||    |
      |   Vulkan Memory Allocator   | |         |+--+ |
      |     |                       | |         |   | |
      *render*----------------------+ +------+  |  *fbx*
        |  |                                 |  |    |
        |  +-------------------------------+ |  |    |
        |                                  | |  |    |
    *clPipeline*                          *application*
         |                                      |
         +-----------------+   +----------------+
                           |   |
                        *editorLib*

Звездочками здесь обозначены модули mtt, а без звездочек указаны внешние библиотеки. Также на схеме нет модуля utilities, от которого зависят все остальные внутренние модули; и не обозначены некоторые второстепенные модули.

# Библиотека render
Библиотека предоставляет базовые классы для построения системы рендера. То есть, сама по себе она не является законченной системой и предполагает, что поверх неё будет построена конечная реализация отрисовки. Тем не менее библиотека берет на себя большую часть низкоуровневой работы.

Кратко пробежимся по структуре папок:
*CommandQueue. Здесь собранны классы, относящиеся к очереди команд Vulkan(VkQueue). Очередь команд хорошо изолирована, и, как правило, нет необходимости в их непосредственном использовании.
*Drawable. Класс Drawable и то, что с ним связано.
*DrawPlan. Классы относящиеся к плану отрисовки.
*Mesh. Меши и базовые техники их отрисовки.
*Pipeline. Обертка вокруг VkPipeline, шейдеры и ресурсы пайплайнов.
*RenderPass. Обертка вокруг VkRenderPass. Проходы рендера. Детальное их изучение можно отложить до того как вам потребуется реализовать собственную систему рендера.
*SceneGraph. Граф сцены, управление объектами в пространстве. Одна из самых часто используемых частей библиотеки.
*SceneRenderer. Высокоуровневые классы для отрисовки сцены. Потребуются, если вы хотите реализовать собственную систему рендера.

## Drawable и план отрисовки (DrawPlan)
Можно сказать, что основная работа библиотеки render заключается в том, чтобы составить план отрисовки и выполнить его. Поэтому классы mtt::Drawable и mtt::DrawPlan являются краеугольными камнями.

DrawPlan - это некоторая последовательность действий, которую надо выполнить, чтобы получить изображение. При этом не надо путать DrawPlan с командным буфером вулкана. DrawPlan выполняется на стороне хоста и занимается, по большому счету, именно заполнением командных буферов. Зачем вообще нужен DrawPlan? Почему нельзя заполнить командный буфер, просто перебирая рисуемые объекты? Причин, на самом деле, всего лишь две - это необходимость сортировки команд и ситуации, когда нужно построить дополнительное изображение(карту теней, например).

Строение плана отрисовки может показаться довольно запутанным, но пока что можно считать его всего лишь набором объектов mtt::AbstractAction, которые и выполняют отрисовку(вернее заполнение буферов команд).

Класс mtt::Drawable - это абстрактный класс объекта, который может добавлять новые действия в план отрисовки. Другими словами, Drawable - это объект, который что-либо рисует. Здесь стоит обратить внимание на 2 вещи. Во-первых, это структура mtt::DrawPlanBuildInfo, которая передается в методы Drawable::addToDrawPlan и Drawable::buildDrawActions. Кроме ссылки на план отрисовки структура содержит большое количество вспомогательной информации: описание размера и типа рисуемого кадра, матрицы преобразования и так далее. Кроме того, ссылка на эту структуру не является константной. То есть процесс построения плана отрисовки имеет изменяемое состояние; а то, как именно объект будет отрисован, зависит от переданного в метод addToDrawPlan значения buildInfo. Это позволяет комбинировать дравэйблы между собой, вкладывая друг в друга, создавать сложные объекты из простых и переиспользовать их в разных местах. Но, обратите внимание, хотя ссылка на buildInfo и не константная, дравейбл должен вернуть его в том же состоянии, что и принял. Изменять buildInfo можно только на время для отрисовки дочерних объектов.

Второй важной особенностью Drawable являются DrawableModificator. Механизм DrawableModificator-ов очень похож на паттерн декоратор (Design Patterns Gamma95). Основной смысл в том, что модификаторы встраиваются между вызовами Drawable::addToDrawPlan и Drawable::buildDrawActions и могут изменять buildInfo, влияя тем самым на отрисовку дравэйбла. Для примера можете посмотреть примитивнейший mtt::VisibleDrawableFilter или более сложный mtt::AntiscaleDrawableModificator.

## Сцена
RenderScene - ещё один краеугольный камень библиотеки render. Можно сказать, что сцена - это структурированный реестр дравэйблов, который позволяет быстро определять, какие дравэйблы и как должны быть отрисованы. Упрощенно можно считать, что объекты находятся на сцене, а во время отрисовки мы запрашиваем у сцены, какие именно объекты подают в кадр, где и как нам их надо нарисовать.

Сцена работает с объектами пяти видов: HUD объекты, 3Д объекты без ограничивающих объемов(unculled drawable), объекты, имеющие ограничивающий объем(culled drawable), модификаторы областей(area modificator) а также композитные объекты(composite object), которые являются комбинациями первых четырех видов.

HUD объекты - это 2D объекты, которые рисуются на экране поверх 3D сцены. Это надписи и элементы GUI(если вы вдруг захотите использовать для этого рендер движок). Честно говоря, вся поддержка HUD графики на сегодняшний момент заключается только в поддержке их сценой. GUI всё-таки проще реализовывать через Qt, поэтому прямой необходимости в HUD объектах ещё не возникало.

3D объекты без ограничивающих объемов - это такие объекты сцены, для которых невозможно заранее указать их размер или местоположение, так как их отрисовка зависит от положения наблюдателя. Это, например, манипуляторы(гизмо), которые имеют фиксированный размер на экране, но плавающий размер на сцене; или задний фон, который перемещается вместе с наблюдателем. Так как отрисовка этих объектов ничем не ограничена, то сцена принимает их как mtt::Drawable объекты, то есть рисоваться они могут вообще как угодно. Но стоит ограничивать их применение, так как невозможно заранее определить, попадают ли они в поле зрения камеры, а значит они будут попадать на отрисовку в каждом кадре.

3D объекты, имеющие ограничивающий объем, позволяют зачительно повысить производительность рендера за счет отсечения объектов, не попадающих в кадр. Сцена принимает их как объекты класса mtt::DrawableNode, то есть это дравейблы, для которых указана локальная система координат и ограничивающая сфера.

Модификаторы областей(mtt::AreaModificator) - это объекты, которые сами непосредственно не создают команд отрисовки, но могут влиять на отрисовку объектов в некотором участке сцены. Хорошим примером тут будут источники света для forward lighting техники, которые влияют на освещаемые объекты, но сами при этом никак не рисуются. Можете, например, посмотреть clPipeline::AmbientLightAreaModificator и его взаимодействие, скажем, с clPipeline::FLColorTechnique. Хотя FLColorTechnique и не является непосредственно потомком Drawable, но она подключается к объекту mtt::Mesh, который и передает ей модификаторы. Одна из основных задач сцены - это как раз таки сообщать DrawableNode, какие модификаторы на них действуют.

Ещё одним важным элементом сцены является филд. Посмотрите на конструктор mtt::RenderScene. Опциональным аргументом здесь является некий AbstractField. Дело в том, что сцена сама по себе не предполагает какое-либо структурирование пространства и не занимается ускорением обхода или кулингом. Решение этих задач может очень сильно отличаться для сцен различного типа. Рендер сцена делегирует эти задачи объекту, производному от AbstractField. Всё что делает филд - это группирует объекты в некоторые области пространства (mtt::FieldArea), распределяет по ним модификаторы и организует обход областей через интерфейс mtt::AbstractField::Visitor.

На сегодняшний момент реализован единственный класс mtt::UnsortedField, который имеет единственную область FieldArea и просто сваливает все объекты в кучу. Не очень-то эффективно. Tсли вам нужны octree или quadtree, то, извините, пока что придётся реализовать их самостоятельно.

## Ноды
Вы, наверное, уже обратили внимание, что mtt::DrawableNode наследуется от двух независимых классов mtt::Drawable и mtt::AbstractNode(через mtt::BoundedNode). Если Drawable определяет возможность объекта быть нарисованным, то AbstractNode определяет нахождение объекта в пространстве. Не все объекты имеют определенное расположение. Тот же туман находится везде, а скайбокс находится там, откуда ведется наблюдение. Так же не все объекты являются рисуемыми; mtt::CameraNode, например, отвечает за расположение наблюдателя и не отрисовывается; mtt::Joint используется для совместного перемещения объектов или добавления жесткой связи между положениями разных объектов и тоже не отрисовывается. Так как эти объекты не принимают непосредственного участия в процессе отрисовки, то они могут даже не регистрироваться в сцене.

AbstractNode - это просто объект, расположенный где-то в пространстве сцены. Мы можем говорить о некоторой локальной системе координат этого объекта, а значит расположение объекта может быть однозначно определено с помощью матрицы трансформации из локальной системы координат в систему координат сцены. Для кого-то это может показаться противоестественным, но эта техника так или иначе используется практически везде, правда, порой скрытно. Библиотека glm позволяет легко преобразовывать привычные координаты+вращение+масштаб в матрицы:

    node.setTransformMatrix(glm::translate(glm::vec3(0.f, 0.f, 3.f)));

Класс mtt::GroupNode - это класс, предназначенный для того чтобы управлять расположением нескольких объектов как единым целым. Пусть у нас есть дом, который состоит из стен, крыши и фундамента. Используем группу, для того чтобы объединить их вместе

    mtt::MasterDrawModel foundationModel(...);
    mtt::MasterDrawModel wallsModel(...);
    mtt::MasterDrawModel roofModel(...);
    mtt::GroupNode house;
    house.addChild(foundationModel);
    house.addChild(wallsModel);
    house.addChild(roofModel);
    house.setTransformMatrix(glm::translate(glm::vec3(2.f, 5.f, 0.f)));

Класс MasterDrawModel будет описан ниже, пока можно считать, что это просто DrawableNode, модель загруженная из файла.

Другим важным типом нод является mtt::Joint. Джоинты используются в тех случаях, когда необходимо сместить и зафиксировать один объект относительно другого. Например, мы можем использовать его для того чтобы закрепить колеса на автомобиле:

    mtt::MasterDrawModel carBodyModel(...);
    mtt::GroupNode carNode;
    carNode.addChild(carBodyModel);
    mtt::Joint wheelJoint;
    mtt::MasterDrawModel whellModel(...);
    wheelJoint.addChild(whellModel);
    carNode.addChild(wheelJoint);
    wheelJoint.setJointMatrix(glm::translate(glm::vec3(3.f, 1.f, 0.f)));

Итак, у нас есть две модели - кузов(carBodyModel) и колесо(whellModel). Для того чтобы объединить их в один объект, мы создаем ноду carNode, которая будет управлять положением автомобиля. К этой ноде мы привязываем модель кузова, поскольку считаем, что положение кузова - это и есть положение автомобиля. Колесо расположено со смещением относительно кузова, поэтому мы используем соединение wheelJoint. Метод Joint::setJointMatrix устанавливает матрицу трансформации из системы координат присоединенных объектов, в систему координат самого джоинта. Работает это примерно так же, как и AbstractNode::setTransformMatrix.

Обратите внимание, что ни mtt::GroupNode, ни mtt::Joint не наследуются от Drawable, поэтому их нельзя добавить в рендер сцену. Вместо этого нам придётся добавлять каждую модель по отдельности. Для того чтобы избавиться и от этой необходимости, можно воспользоваться классом mtt::CombinedDrawableNode. Это DrawableNode, которая сама может состоять из нескольких DrawableNode. Пример с машиной можно переписать таким образом:

    mtt::CombinedDrawableNode carNode;
    mtt::MasterDrawModel bodyModel(...);
    carNode.addNode(bodyModel);
    mtt::MasterDrawModel wheelModel(...);
    carNode.addNode(wheelModel);
    wheelModel.setTransformMatrix(glm::translate(glm::vec3(3.f, 1.f, 0.f)));

Теперь мы можем добавить машину в рендер сцену как единый объект:

    scene.addCulledDrawable(carNode);

Обратите внимание, для того чтобы сместить колесо относительно автомобиля мы использовали setTransformMatrix. Дело в том, что CombinedDrawableNode подменяет мировую систему координат на собственную, что позволяет в ряде случаев обходиться без джоинтов или переиспользовать некоторые дравэйблы в нескольких CombinedDrawableNode сразу.

## Меши
До сих пор мы рассматривали абстрактные типы и общие понятия. Что же, добавим немного конкретики и действия. Меш - это универсальный дравейбл, предназначенный для отрисовки полигональных моделей. Впрочем, он поддерживает все топологии, доступные в вулкане, рисовать можно и точками, и линиями. Декларация mtt::Mesh выглядит довольно громоздко, но на самом деле большая её часть - вспомогательный функционал для сокращения рутинных задач.

Весьма полезно будет иметь перед глазами пример 02_Mesh из папки applications/Examples.

Суть меша очень проста - это состыковка данных, которые необходимо отрисовывать, с методами отрисовки.

Традиционно рендер происходит в виде наборов точек, линий или треугольников. Так или иначе все эти примитивы опираются на основной тип данных рендера - вершины(или вертексы). Вершины поставляются в меш через вершинные буферы. Вершинный буфер - это экземпляр класса mtt::Buffer; можно представлять его просто как участок памяти на стороне видеокарты. Вообще, данные вершин могут быть любого типа из mtt::VertexAttribute::DataType, обозначать любые свойства и визуализироваться произвольным образом. Меш не ограничивает тут вашу фантазию, можете передавать температуру, давление или количество котиков на квадратный метр. Общим методом для добавления вершинного буфера является Mesh::addVerticesBuffer. Первый параметр - это буфер с данными, второй - имя буфера, по которому буфер будет опознан и правильно отрисован.

Хотя меш может работать с данными вершин любого назначения, но есть типы данных, используемых постоянно и повсеместно, такие как позиции, нормали, текстурные координаты и т.д. Для того чтобы их стандартизировать и сократить рутину, меш имеет специализированные методы Mesh::setPositionBuffer, Mesh::setNormalBuffer и т.д. Посмотрите как происходит добавление вершинных буферов в примере 02_Mesh:

    std::vector<glm::vec3> positionsData ={ glm::vec3(-1.f, -1.f, 0.f),
                                            glm::vec3(-1.f,  1.f, 0.f),
                                            glm::vec3( 1.f, -1.f, 0.f),
                                            glm::vec3(-1.f,  1.f, 0.f),
                                            glm::vec3( 1.f,  1.f, 0.f),
                                            glm::vec3( 1.f, -1.f, 0.f) };

    std::shared_ptr<mtt::Buffer> positionBuffer =
      std::make_shared<mtt::Buffer>(displayDevice, mtt::Buffer::VERTEX_BUFFER);
    positionBuffer->setData(positionsData.data(),
                            positionsData.size() * sizeof(positionsData[0]));

    mesh.setPositionBuffer(positionBuffer);

Кроме самих данных необходимо указать и количество вершин:

    mesh.setVerticesNumber(positionsData.size());

Если вы пользовались OpenGL или Vulkan, то наверняка знаете о такой вещи как индексный буфер. Подключить его к мешу можно с помощью метода Mesh::setIndices. Обратите внимание, что к мешу можно подключить несколько индексных буферов, по одному на каждый тип топологии.

Кроме данных, жестко привязанных к вершинам, для рендера скорее всего понадобятся дополнительные данные, например свойства материала, текстуры или, скажем, текущее атмосферное давление. Для управления этими данными используется класс mtt::ExtraData. Получить доступ к нему можно через метод Mesh::extraData. Всего существует 3 типа дополнительных данных: униформ буферы, сэмплеры и хост-данные.

Если вы уже имеете опыт работы с вулканом или OpenGL, то скорее всего униформ буферы вам известны. По существу, это участки памяти на стороне GPU, к которым шейдеры имеют произвольный доступ на чтение. Общий метод для добавления униформ буферов - MeshExtraData::addUniformBuffer. Так же как и для вершинных буферов, вы должны указать имя, по которому этот буфер может быть опознан и правильно использован. Сейчас есть только одно стандартизированное использование униформ буферов - это передача свойств материала. Используйте для этого метод MeshExtraData::setSurfaceMaterialData.

Сэмплеры - это механизм подключения текстур. На текущий момент mtt поддерживает 2D текстуры (mtt::Texture2D) и кубические текстуры(mtt::CubeTexture). Связь между текстурой и сэмплером аналогична таковой в вулкане. Можно сказать, что текстура - это данные, которые могут быть разделены между множеством дравэйблов, а сэмплер - это механизм извлечения этих данных во время отрисовки. Как и для других данных, есть один универсальный метод добавления сэмплеров(MeshExtraData::addSampler) и множество методов для сэмплеров со стандартным назначением(setAlbedoSampler, setOpaqueSampler и т.д.). Вы можете посмотреть пример использования сэмплеров в примере applications/Examples/02_Mesh.

Данные хоста(variables) - это всего лишь способ хранить в меше произвольные данные, не отправляя их напрямую на GPU. Этот функционал может вам потребоваться только при создании своих собственных кастомных техник отрисовки. Сейчас мы опустим подробности.

До сих пор мы рассматривали только данные меша, но вторая важная его часть - это отрисовка данных, за которую отвечают техники рисования. Все они наследуются от абстрактного класса mtt::AbstractMeshTechnique. Класс имеет множество виртуальных методов в public секции, но не беспокойтесь, все они вызываются исключительно через mtt::Mesh или mtt::ExtraData, вам не надо их трогать до того момента, пока вы не решите создать свою кастомную технику рисования. Назначить мешу технику рисования можно через метод Mesh::setTechnique. Пример такого подхода можно увидеть в примере applications/Examples/02_Mesh:

    mesh.setTechnique(
              mtt::clPipeline::colorFrameType,
              std::make_unique<mtt::clPipeline::UnlightedColorTechnique>(
                                          true,
                                          true,
                                          VK_COMPARE_OP_GREATER_OR_EQUAL,
                                          VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST));

Обратите внимание, что первым параметром тут стоит тип фрэйма(кадра). Библиотека mtt поддерживает не только рендер видимой цветной картинки, но и другие типы изображений: карта глубины, карта теней, карта идентификаторов. Для каждого типа кадра можно установить свою собственную технику рисования, а можно и не устанавливать, тогда меш не будет отрисован в этом кадре вовсе. Библиотека render предоставляет только самые примитивные техники - mtt::DepthMeshTechnique для рисования в карту глубины и mtt::UidMeshTechnique для рисования в карту идентификаторов. Техники отрисовки в цветовое изображение уже зависят от конкретной реализации рендера и предоставляются самими реализациями. Так, например, реализация mtt::clPipeline предоставляет техники mtt::clPipeline::ModelCompositeColorTechnique для цветового рендера и mtt::clPipeline::ShadowmapMeshTechnique для отрисовки в карту теней.

Другой способ назначить техники мешу - это фабрики техник. Библиотека render предоставляет только абстрактный класс mtt::MeshTechniquesFactory, конкретные реализации предоставляются готовыми рендер системами, так clPipeline предоставляет mtt::clPipeline::ModelTechniquesFactory. В примере applications/Examples/03_Model можно увидеть использование фабрики при загрузке модели

    mtt::clPipeline::ModelTechniquesFactory techniquesFactory(
                                          true,
                                          false,
                                          false,
                                          false,
                                          false,
                                          VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);
    ...
    drawModel(":/Dino.mmd", techniquesFactory, nullptr, displayDevice),

# Библиотека application
Пора добавить немного Qt в нашу унылую жизнь! Ну а если серьёзно, то библиотека application - просто набор утилит, завязанных на Qt и библиотеке mtt::render, которые могут облегчить жизнь при написании 3D приложений.

## Класс Application
Первое, на что стоит обратить внимание, это класс mtt::Application. Подобно тому, как вы создаёте QApplication перед использование Qt, вы должны создать mtt::Application перед тем как будете использовать эту библиотеку. На самом деле mtt::Application наследуется от QApplication, так что создавать вам придётся всего один объект. Этот класс делает некоторое количество грязной работы, такой как инициализация и настройка mtt::render, организация цикла работы приложения и т.д. Вникать в это пока не обязательно, просто помните, что этот объект надо создать.

## RenderWidget
RenderWidget - это виджет Qt, на который рендерится сцена. Его использование весьма незамысловато, можете посмотреть пример applications/Examples/01_Empty. Всё что вам надо, это указать какая сцена, с какой камеры и как будет отрисовываться. Сцена и камера устанавливаются методом RenderWidget::setSource. Система рендера устанавливается методом RenderWidget::setFrameBuilder. Пока вы не собрались делать собственную систему рендера, можете использовать mtt::clPipeline::ColorFrameBuilder.

    mtt::RenderScene scene;
    mtt::CameraNode camera;
    camera.setPerspectiveProjection(glm::pi<float>() / 2.f, 1.33f, 0.1f, 50.f);
    window.setSource(&scene, &camera);
    mtt::clPipeline::ColorFrameBuilder colorFrameBuilder(
                                                  window.surfaceFormat(),
                                                  application.displayDevice());
    window.setFrameBuilder(&colorFrameBuilder);

С RenderWidget связан ещё один весьма полезный класс - это mtt::OrbitalCameraController. Его использование можно посмотреть во многих примерах, начиная с 02_Mesh. Контроллер камеры подключается к рендер виджету и перехватывает управление камерой, позволяя пользователю перемещаться по сцене с помощью мыши. Левая кнопка мыши используется для вращения камеры, правая для перемещения в горизонтальной плоскости, средняя - для перемещения в вертикальной плоскости.

## Модели
Заполнять меши вручную - весьма нудное и неблагодарное занятие. Гораздо удобнее импортировать 3D модели из внешних файлов. Классы mtt::MasterModel и mtt::SlaveModel предназначены именно для этого.

Сейчас поддерживаются форматы fbx, obj и mmd. MMD - это внутренний формат библиотеки mtt, вы можете использовать ObjectEditor для создания файлов в этом формате.

Итак, что такое модели, и зачем понадобилось создавать 2 типа моделей?

Мастер модель(класс mtt::MasterDrawModel) - это просто DrawableNode, объединяющий в себе набор мешей, иерархию объектов mtt::Joint для создания скелетных анимаций и сами анимации. Вы, конечно, можете создать пустую модель и вручную добавить в неё необходимые объекты, но, скорее всего, вы будете пользоваться конструктором, загружающим модель из файла.

    mtt::MasterDrawModel dinoModel( ":/Dino.mmd",
                                    techniquesFactory,
                                    textureLibrary,
                                    displayDevice),

О фабриках(techniquesFactory) техник мы уже говорили в разделе "Меши". Смысл тот же, фабрики используются для создания техник рисования, можете воспользоваться классом mtt::clPipeline::ModelTechniquesFactory, если, конечно, вы используете clPipeline как систему рендера. Библиотека текстур(textureLibrary) - это хранилище текстур, совместно используемых сразу многими моделями. Библиотеки порой значительно экономит память. О них речь пойдет позже, пока можете просто передать nullptr, чтобы не использовать этот функционал. Рендер устройство(displayDevice) - это логическое устройство рендера, обертка вокруг VkDevice; то есть устройство, с помощью которого предполагается производить отрисовку. Как правило, вы будете работать с устройством, использующимся оконной системой, так что можете использовать mtt::Application::displayDevice(), чтобы получить его.

После того как модель загружена, вы можете пользоваться ею как обычной DrawableNode, то есть добавлять в сцену(culled и unculled) и иерархию joint-ов. Кроме того, вы можете обновить состояние самой модели с помощью анимаций (метод MasterDrawModel::updateFromAnimation). Доступные анимации хранятся в самой модели, и могут быть получены через методы MasterModel::animationsNumber, MasterModel::animationName, MasterModel::animation, MasterModel::findAnimation.  Посмотрите пример applications/Examples/03_Model, где показано использование масте моделей.

А теперь представим себе ситуацию, когда нам нужно нарисовать, скажем, роту солдат. Как это сделать? Можно, конечно, загрузить 100 моделей из одного и того же файла и отрисовывать их независимо. Но в этом случае мы получаем гигантские потери на дублировании данных, даже если мы используем общие текстуры. Можно попробовать загрузить одну модель и использовать её, подключая к разным mtt::SimpleDrawableNode или mtt::CombinedDrawableNode. Но в этом случае мы теряем возможность нормально пользоваться анимациями, так как применение анимации приведет к тому, что модель будет изменена для всех мест, где она отрисовывается. Именно для решения этого противоречия и используются слэйв модели.

Слэйв модель (класс mtt::SlaveDrawModel) - это так же DrawableNode, но в отличие от мастер модели, слэйв модель не поддерживает загрузку из файла. Вместо этого она строится на основу уже загруженной модели, мастер модель при этом становится разделяемым объектом и блокируется (можно вызывать только константные методы мастер модели). Слэйв модель имеет собственную иерархию джоинтов, поэтому анимация, примененная к одной слэйв модели, не окажет влияния на остальные модели. Посмотрите пример applications/Examples/04_SlaveModel, где показано, как использовать слэйв модели на практике.

## Библиотеки ресурсов
Библиотеки ресурсов - это технология для централизации загрузки и хранения разделяемых ресурсов. На текущий момент это mtt::Texture2DLibrary для 2D текстур, mtt::CubeTextureLibrary для кубических текстур и mtt::DrawModelLibrary для моделей. Все они унаследованы от шаблонного класса mtt::ResourceLibrary, который, в сущности, является потокобезопасной оберткой вокруг std::map.

Класс mtt::Application не содержит в себе каких-либо библиотек ресурсов, и вы можете использовать или не использовать их на своё усмотрение. Можно, например, использовать схему с единым хранением ресурсов, когда все библиотеки включены в объект Application и, по существу, являются синглтонами. Так, например, сделано в mtt::EditorApplication. Либо вы можете создавать отдельные библиотеки для каждой из сцен, чтобы иметь более гибкое управление ресурсами.

## mtt::Object
Если вы собираетесь создавать собственный редактор, то скорее всего вы так или иначе будете использовать схему MVC. За model часть этой схемы в mtt отвечают сцены (класс mtt::Scene, не путать с RenderScene) и объекты(базовый класс mtt::Object)

Класс mtt::Object - это базовый класс для объектов модели. Он унаследован от класса QObject, но сделано это, главным образом, для использования механизмов сигнал-слот и QEvent.

Первое отличие, которое бросается в глаза - это наличие идентификатора(id). Идентификатор - это случайное 64 разрядное число, поставленное в соответствие объекту. Именно идентификатор, а не адрес в памяти, используется, когда необходимо сделать ссылку на объект. Дело в том, что после сериализации/десериализации, когда вы, например, сохранили сцену на диск, а потом прочитали её, объекты сцены будут созданы по новым адресам.

Конструктор mtt::Object позволяет вам принудительно назначить id объекта. Этот способ используется в основном при загрузке, когда важно сохранить связи между объектами. Если вы передадите пустой id(или не укажете его в конструкторе), то объекту будет назначен случайный идентификатор. Используйте этот метод для вновь создаваемых объектов.

    mtt::Object object1("Object1", true, mtt::UID(985)); //Создается объект с id = 985
    mtt::Object object2("Object2", true, mtt::UID());  //Создаются объекты со
    mtt::Object object3("Object3", true);              //случайными id

Следующее, на что стоит обратить внимание, это имена объектов. В отличии от QObject, где вы всегда можете переименовать объект, mtt::Object может заблокировать переименование. Это произойдет, если вы передадите в конструктор canBeRenamed = false. Это может быть полезно, когда вы не хотите, чтобы пользователь мог переименовывать какие-то специфичные части сцены. Например, группы "Animations", "Geometry", "Materials" и "Skeleton" в ObjectEditor-е.

    mtt::Object object1("Object1", true);
    object1.tryRename("New name");          //Объект будет переименован

    mtt::Object object2("Object2", false);
    object1.tryRename("New name");          //Объект не будет переименован

Обратите внимание, что объекты не обязаны иметь уникальные имена. Имя - это всего лишь строка для элементов GUI.

Третья особенность mtt::Object - это поддержка подобъектов. Каждый объект может состоять из произвольного числа подобъектов (или, другими словами, содержать их). Их количество и ссылки на них можно получить с помощью методов mtt::Object::subobjectNumber и mtt::Object::subobject. Но добавить произвольный подобъект или удалить подобъект в общем случае не всегда возможно, методы addSubobject и removeSubobject находятся в protected области. Конкретные реализации должны сами предоставлять публичные методы для манипуляции подобъектами, как, например, mtt::ObjectGroup. Кроме того, можно воспользоваться методами Object::subobjectCanBeAdded, Object::tryAddSubobject, Object::subobjectCanBeRemoved и Object::tryRemoveSubobject, если вы имеете доступ только к интерфейсу mtt::Object.

Библиотека mtt::application вводит ещё два типа объектов. Класс mtt::ObjectGroup - это группа, в которую могут быть добавлены или удалены объекты любого типа. По существу, это просто перенос методов класса mtt::Object из protected области в public. Шаблонный класс mtt::SpecialGroup - это группа, которая позволяет добавлять и удалять объекты только определенного класса(или производных от него классов). Специальные группы довольно широко используется в качестве базового класса, так как позволяет убрать огромное количество рутины из многих объектов. Можете посмотреть, например, mtt::AnimationObject.

## ObjectItemListModel и ObjectItemTreeModel
Посмотрите пример applications/Examples/08_Objects. Объекты в нем объединяются в древовидную структуру, а сама структура объектов визуализируется с помощью виджета QTreeView.

Классы ObjectItemListModel и ObjectItemTreeModel - это адаптеры, которые обеспечивают связь между виджетами QListView и QTreeView с одной стороны и иерархией mtt::Object-ов с другой.

## mtt::Scene и ссылки на объекты
Класс mtt::Object и производные от него классы, в принципе, уже позволяют построить объектную модель для приложения. Трудности могут возникнуть, когда вам потребуется организовать связь между объектами.

История с ссылками довольно запутанная, поэтому рассмотрим всё на примере. Итоговый код примера вы можете найти в applications/Example/09_ObjectLink

Пусть у нас есть некоторый человек по имени Боб. Боб - мастер и умеет забивать болты, стоит только его попросить об этом.

    class Bob : public mtt::Object
    {
      Q_OBJECT

    public:
      Bob() : Object("Bob", false)
      {
      }

      void toHammer()
      {
        mtt::Log() << "Bob hammers a bolt";
      }
    };

Также у нас есть некто Билл, который сам работать не умеет, поэтому просит Боба.

    class Bill : public mtt::Object
    {
      Q_OBJECT

    public:
      Bob* bobLink;

    public:
      Bill() :
        Object("Bill", false),
        bobLink(nullptr)
      {
      }

      void askBob()
      {
        if(bobLink != nullptr) bobLink->toHammer();
        else mtt::Log() << "Bob is gone";
      }
    };

Казалось бы всё хорошо, нам надо только передать указатель на Боба, и Билл сможет с ним работать. Но есть две проблемы, особенно хорошо проявляющиеся, когда Бобов и Биллов станет много.

Во-первых, сохранять и загружать наши объекты надо в определенном порядке. Сначала надо сохранить всех Бобов, а потом всех Билов, чтобы при загрузке Билов, Бобы были уже созданы и мы могли бы установить bobLink.

Вторая проблема возникает, если Боб периодически нам нужен, чтобы что-то делать в другом потоке. Можно, конечно, вручную установить bobLink в nullptr перед уходом Боба, а потом вручную вернуть его обратно. Но, во-первых, к одному Бобу может быть подключено сразу несколько Биллов, и нам надо как-то их всех найти. А во вторых, Бобов тоже может быть несколько, и нам всё равно надо помнить, к какому именно Бобу был привязан Билл, даже когда Боб работает в другом потоке.

Для решения этих проблем используется класс mtt::Scene. Сцена - это просто реестр объектов, которые могут работать совместно в одном потоке. Когда вы регистрируете объект в сцене(mtt::Scene::registerObject), то в сцене также добавляются и все субобъекты. При этом сцена обходит все объекты, которые в ней зарегистрированы и сообщает о прибытии новичков (метод mtt::Object::notifyAboutAppearance). Тем же способом сцена информирует новый объект о том, какие объекты в сцене уже есть. Когда объект дерегистрируется из сцены, то всё происходит точно так же, только уже используется метод mtt::Object::notifyAboutDisappearance.

По идее, этого уже достаточно, чтобы решить наши проблемы, достаточно лишь хранить id Боба и отслеживать его появление в сцене. Но всё это - довольно хлопотное занятие, поэтому библиотека applicatoion содержит шаблонный класс mtt::ObjectLink, скрывающий большую часть рутины. Класс Bill можно теперь переписать так:

    class Bill : public mtt::Object
    {
      Q_OBJECT

    public:
      using BobLink = mtt::ObjectLink<Bob, Bill, nullptr, nullptr, nullptr>;
      BobLink bobLink;

    public:
      Bill() :
        Object("Bill", false),
        bobLink(*this)
      {
      }

      void askBob()
      {
        if(bobLink != nullptr) bobLink->toHammer();
        else mtt::Log() << "Bob is gone";
      }
    };

Пример applications/Examples/09_ObjectLink содержит вариант с более полным набором возможностей, которые, впрочем, вы можете и не использовать.

## Команды и undo/redo
Мы уже разобрались с "модель" и "вью" компонентами схемы MVC, остались контроллеры. Здесь, на самом деле, нет чего-то необычного, просто реализация паттерна Command(Design Patterns Gamma95).

Библиотека application предоставляет вам следующие классы команд:
* AbstractEditCommand - абстрактный класс команды, от которого наследуются все остальные команды.
* SetPropertyCommand - шаблонный класс команды, которая меняет значение какой-то величины в объекте.
* SetReferenceCommand - шаблонный класс команды, которая устанавливает ссылку на объект.
* AddObjectCommand - команда, которая добавляет субобъект в объект.
* RemoveObjectCommand - команда, которая убирает субобъект из объекта.
* MoveObjectCommand - команда, которая перемещает субобъект из одного объекта в другой.
* CompositeCommand - составная команда, которая может состоять из произвольного числа любых типов команд. Используется при группировке, когда необходимо сделать так, чтобы несколько действий выполнялись за один вызов undo.

Для хранения и выполнения команд используется класс mtt::UndoStack. Большинство его методов имеют говорящие названия и в дополнительных комментариях вряд ли нуждаются. Единственный, что может быть тут непонятно, это, пожалуй, GroupLocker. По большому счету, GroupLocker - это RAII обертка для растянутого во времени создания групповых команд. Используется, например, в манипуляторах или спин виджетах. Можете посмотреть, например, его применение в mtt::PlaneManipulator из библиотеки editorLib.

Посмотрите пример applications/Examples/10_Commands, в котором показаны основные приемы работы с командами и UndoStack.

## Виджеты свойств
Использование шаблонного класса mtt::SetPropertyCommand может вогнать в уныние, особенно если вам надо использовать его каждый раз, когда вы создаете виджет для управления каким-либо объектом. Естественно, что библиотека application дает возможность значительно сократить эту рутину. Загляните в папку include/mtt/application/Widgets/PropertiesWidgets. Здесь собраны классы, закрывающие большую часть потребностей при создании GUI свойств. В папке вы обнаружите в основном объекты двух типов - это виджеты и соединения(connection). Оба они работают со свойствами объектов. Свойство здесь - это некоторое значение внутри объекта, для которого есть геттер, сеттер и сигнал об изменении. Например:

    class MyObject : public QObject
    {
      Q_OBJECT
    public:
      MyObject() :
        _weight(0)
      {
      }
      float weight() const noexcept
      {
        return _weight;
      }
      void setWeight(float newValue)
      {
        if(_weight == newValue) return;
        _weight = newValue;
        emit weightChanged(newValue);
      }
    signals:
      void weightChanged(float newValue);
    private:
      float _weight;
    };

Соединения - это шаблонные классы, которые берут на себя всю рутину по синхронизации свойств объектов с элементами GUI. Все они имеют трехсоставное название, например FloatSpinConnection или BoolCheckboxConnection. Первая часть - это тип свойства, с которым они связаны, вторая часть это тип виджета, к которому подключается соединение, третья часть - всегда Connection. FloatSpinConnection - это соединение, которое синхронизирует QDoubleSpinBox со свойством типа float. Пользоваться соединением очень просто : всё что надо, это просто создать его. Посмотрите пример applications/Examples/11_PropertiesWidgets.

Соединения удобны, когда вы используете Qt designer для создания диалогов или виджетов. Посмотрите, например, mtt::LightWidget из библиотеки editorLib. Если вы собираете GUI вручную из отдельных элементов, то можете воспользоваться готовыми виджетами, такими как FloatPropertySpin или Vec3PropertyWidget, как это сделано в applications/Examples/11_PropertiesWidgets для виджета slider.

## Манипуляторы
Важной частью многих 3D приложений являются манипуляторы(или гизмо). Это те самые элементы управления, за которые вы можете перетаскивать и поворачивать объекты прямо в окне рендера.

Поддержка манипуляторов в библиотеке application несколько своеобразна. Библиотека не дает вам готового решения в стиле "подключил и работает". Вместо этого вам предоставляется набор абстрактных классов, на основе которых вы можете построить свою систему манипуляторов. Действительно, библиотека application не знает ничего об иерархии классов вашего приложения, не знает как будут реализованы 3d объекты, не знает даже, будете ли вы использовать clPipeline или напишете свою систему рендера. Тем не менее, в библиотеке editorLib уже реализованы законченные манипуляторы, можете воспользоваться ими, если согласны быть привязанными к классу mtt::MovableObject и рендеру clPipeline.

Максимально упрощенный пример использования манипуляторов вы можете посмотреть в applications/Examples/06_Manipulator.

Знакомство с манипуляторами стоит начать с классов mtt::AbstractManipulator и mtt::ManipulatorController. ManipulatorController - это класс-адаптер, который подключается к рендер виджету, перехватывает часть событий GUI и интерпретирует их в команды для манипуляторов. Всё что вам необходимо - просто создать контроллер и подключить к нему манипулятор.

    mtt::ManipulatorController manipulatorController(renderWidget);
    manipulatorController.setManipulator(&manipulator);

Название AbstractManipulator говорит само за себя. Этот класс предоставляет множество виртуальных методов для взаимодействия с контроллером и вводит понятие "состояние". Всего есть три состояния манипулятора:
* UNSELECTED - манипулятор отрисовывается где-то на сцене, при этом находится в состоянии покоя.
* HIGHLITED - пользователь навел мышь на манипулятор. Манипулятор при этом, как правило, изменяет свой вид(обычно меняет цвет, подсвечивается). При этом работа с манипулятором ещё не началась, он всего лишь показывает, что готов к работе и будет активирован, если нажать на кнопку мыши.
* ACTIVATED - манипулятор активирован для того чтобы вносить какие-либо изменения на сцене.

Класс Manipulator3D дополняет AbstractManipulator единственным виртуальным методом Manipulator3D::node, который возвращает объект mtt::AbstractNode. То есть Manipulator3D позволяет определять его положение в 3D и управлять этим положением.

От класса Manipulator3D наследуются 2 типа манипуляторов: Simple3DManipulator и Composite3DManipulator. Composite3DManipulator - это просто способ сгруппировать несколько простых манипуляторов в один. Можете посмотреть в качестве примера mtt::MoveManipulator или mtt::RotationManipulator из библиотеки mtt::editorLib.

Simple3DManipulator - это абстракция для построения манипулятора, выполняющего одно простое действие, например перемещение вдоль плоскости или вращение вокруг одной оси. Этот манипулятор реализует рисование и проверку на пересечение с указателем мыши. От него наследуются ещё 4 вида, которые, скорее всего, и будут использованы:
* AxisMove3DManipulator - перемещение вдоль локальной оси Z.
* PlaneMove3DManipulator - перемещение вдоль локальной плоскости XY.
* RingRotation3DManipulator - вращение вокруг локальной оси Z.
* UniformScale3DManipulator - равнонаправленное масштабирование.

Всё что вам надо сделать для того чтобы пользоваться кем-либо из них - это создать геометрию, установить технику рисования, а также переопределить обработчик перетаскивания(в каждом классе он свой). Посмотрите пример applications/Examples/06_Manipulator.

Хотя логика работы простых манипуляторов и привязана жестко к одной оси, ничего не стоит изменить направление этой оси в мировых координатах. Используйте mtt::Joint для управления положением манипуляторов, как это сделано, например, в mtt::RotationManipulator:

    glm::mat4 xManipulatorTransform = glm::rotate(glm::radians(90.f),
                                                  glm::vec3(0, 1, 0));
    _xManipulatorJoint.setJointMatrix(xManipulatorTransform);
    ...
    _xManipulatorJoint.addChild(_xManipulator.node());
    registerSubmanipulator(_xManipulator, _xManipulatorJoint);

RotationManipulator - это составной манипулятор, состоящий из 3-х RingRotation3DManipulator-ов. Каждый из них отвечает за вращение вокруг своей оси. Для того чтобы _xManipulator вращал объект вокруг оси x, а не z, мы используем mtt::Joint, дополнительно поворачивая манипулятор.